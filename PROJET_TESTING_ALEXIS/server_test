#!/bin/bash

# Ce script implémente un serveur.
# Le script doit être invoqué avec l'argument :                                                              
# PORT   le port sur lequel le serveur attend ses clients 

if [ $# -ne 1 ]; then
    echo "Erreur, port manquant"
    exit -1
fi

PORT="$1"

# Déclaration du tube

FIFO="/tmp/$USER-fifo-$$"

# Il faut détruire le tube quand le serveur termine pour éviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour être sur de
# nettoyer même si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT

# on crée le tube nommé

[ -e "FIFO" ] || mkfifo "$FIFO"


function accept-loop() {
    while true; do
		interaction < "$FIFO" | netcat -l -p "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entrée standard
# et envoie les réponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une réponse d'erreur.

browseMode=false
currentDirectory='\'

#Fonction interaction avec l'utilisateur
function interaction() {
    local cmd args
    while true; do
		read cmd args || exit -1
		if $browseMode; then #Si browsemode est vrai (Si l'user a invoquer la fontion browsemode)
			fun="browse-$cmd" #browse-commande tapée stockée
		else
			fun="commande-$cmd" #SI browsemode a pas été appellée alors le serveur attend autre commande
		fi
		if [ "$(type -t $fun)" = "function" ]; then
	    	$fun $args
	    elif [ "$fun" = "browse-exit" ]; then #Si je quitte browsemode, alors je retourne en saisi de commande classique
	    	browseMode=false
		else
		   	commande-non-comprise $fun $args
		fi
		if $browseMode; then #SI jsuis en browse mode, j'affiche vsh
			echo "vsh:>"
		fi
    done
}

# Les fonctions implémentant les différentes commandes du serveur

function commande-list() {
	ls=$(ls archives)
	if [ -n "$ls" ]; then
		echo "Les archives présentes sur le serveur sont :"
		echo $ls
	else
		echo "Pas d'archives présente sur le serveur"
	fi
}

function commande-create() {
nomArchive=$1 #Argument saisie (Nom de l'archive)
	if [ -n "$nomArchive" ]; then #SI l'argument saisie est pas vide
		occurence=false #Flag a false
		for i in $(ls archives); do #On a crée au préalable un dossier archive qui va contenir toutes les archives
			if [ "$nomArchive" = "$i" ]; then #SI on veut crée un une archive avec le meme nom
				occurence=true #OCcurence = true
				break
			fi
		done
		if $occurence; then #SI TRUE alors impossible de créer logique !
			echo "création impossible, une archive porte déjà ce nom"
		else
			echo "3:5" >> archives/$nomArchive #Sinon, on met tout en haut du fichier 3:5 comme dans l'énoncé et on crée automatique le fichier avec >>
			echo "Le fichier a été créé avec succès"
		fi
	else
		echo "création impossible, pas de nom fourni pour l'archive"
	fi
}


#Fonction invoquer browse
function commande-browse() {
	eval nomArchive=$1 #Argument
	if [ -n "$nomArchive" ]
	then #Si argument est une chaine non vide (Donc il existe)
		trouve=$(ls archives | grep -c $nomArchive)
		if [ $trouve -eq 0 ]
		then
			echo "Navigation impossible, aucune archive de ce nom sur le serveur"
		else
			browseMode=true
			eval path='archives/$nomArchive'
		fi
	else
		echo "Navigation impossible, pas de nom fourni pour l'archive" #Sinon on dit qu'on peut pas car aucun nom fourni (où le serveur peut aller ?)
	fi
}

function browse-pwd() {
	echo $currentDirectory
}

find=false
#Fonction extraction
function commande-extract() {
	nomArchive=$1 #Argument (Le nom de l'archive que l'utilisateur souhaite extraire pour la mettre sur sa machine !)
	for i in $(ls archives)
	do
        	if [ "$nomArchive" =  "$i" ]
		then
			find=true
			echo "Vous devez initialiser la connexion en tapant la commande ..."
			read input
			if [ "$input" == "ncat -l | tar xzv" ]
			then
				tar czv -v $i | ncat --send-only localhost #Commande pour extraire l'archive
			else
				echo "Vous n'avez pas initialiser la connexion"
			fi
		fi
        done
	if [ find=false ]
	then
		echo "Aucun fichier qui répond à ce nom dans le serveur"
	fi
}

#Fonction pour insérer une ligne dans l'archive (Fichier vide) à l'endroit spécifié par l'utilisateur et dans l'archive donné par l'user
function browse-touch() {
	cheminFichier=$1 #Chemin du fichier entré par l"utilisateur  ( Dans quel dossier je dois foutre le fichier vide ) (Me donne la ligne où inserer mon fichier vide dans le texte !)
	if [ -z $cheminFichier ]
	then
		echo "Erreur, aucun argument"
		return
	elif [ -n $cheminFichier ] # l'argument est entré
	then

		nomFichier=$(echo $cheminFichier | rev | cut -d"\\" -f 1 | rev) # Je récupère la nom du fichier entré par l'user ( Dernier champ )
		occurence=$(grep -c $nomFichier $path) #Chercher si le fichier existe dans le fichier texte ( Je cherche si le nom apparait dans une ligne )
		if [[ $occurence -ne 0 ]]
		then
			echo "Le fichier existe déjà dans l'archive"
		else
			arbo=$(echo $cheminFichier | rev | cut -d "\\" -f2- | rev) #Je recupère l'arbo donné par l'user avec des commandes CUT
			replace=$(echo $arbo | sed 's/\\/\\\\/g') #Echapper les '\' pour éviter les bugs avec Grep 
			occurence2=$(grep -c $replace $path) #Je regarde s'il y a occurence de l'arbo dans le fichier texte
			match=$(echo $replace | rev | cut -d"\\" -f1 | rev) #Prendre le dernier champ de l'arbo pour que sed puisse match une ligne ET une seule
			if [[ $occurence2 -ne 0 ]] #Si occurence est different de 0, l'arbo existe (Chaine trouvée) donc je peux insérer mon fichier
			then
				sed -i "/\($match\)$/a $nomFichier -rw-rw-r-- 0 0 0" "$path" #Insertion du fichier vide au bon endroit (En dessous de la ligne finissant par $match regex)
				cat $path
				echo "Fichier vide inséré dans l'archive avec succès !"
			else
				echo "L'arborescence décrite n'existe pas dans l'archive" #Pas d'arbo existente donc erreur
			fi
		fi
	fi
} #Fixer Luser qui rentre des \\

#Fonction pour dire que le serveur a pas comprit la commande
function commande-non-comprise() {
   echo "Le serveur ne peut pas interpréter cette commande"
}

# On accepte et traite les connexions

accept-loop
